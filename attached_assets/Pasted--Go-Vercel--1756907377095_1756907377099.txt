Твоя задача создать телеграм бота на Go который можно будет задеплоить на Vercel. Бот будет выступать школьным Электронным дневником. Напиши основу я пришлю после ТЗЕще смотри нам надо сделать чтобы на экране дневника можно было выбрать неделю так вот нам придется сделать запрос при открытии страницы дневника на дневник и на периоды вот ответ на запрос периодов
{
  "response": {
    "state": 200,
    "error": null,
    "result": {
      "students": [
        {
          "name": 1018,
          "title": "Мельник Даниил",
          "periods": [
            {
              "name": "I",
              "fullname": "I четверть",
              "disabled": false,
              "ambigious": null,
              "start": "20240903",
              "end": "20241102",
              "weeks": [
                {
                  "start": "20240902",
                  "end": "20240908",
                  "title": "02 сентября &mdash; 08 сентября"
                },
                {
                  "start": "20240909",
                  "end": "20240915",
                  "title": "09 сентября &mdash; 15 сентября"
                },
                {
                  "start": "20240916",
                  "end": "20240922",
                  "title": "16 сентября &mdash; 22 сентября"
                },
                {
                  "start": "20240923",
                  "end": "20240929",
                  "title": "23 сентября &mdash; 29 сентября"
                },
                {
                  "start": "20240930",
                  "end": "20241006",
                  "title": "30 сентября &mdash; 06 октября"
                },
                {
                  "start": "20241007",
                  "end": "20241013",
                  "title": "07 октября &mdash; 13 октября"
                },
                {
                  "start": "20241014",
                  "end": "20241020",
                  "title": "14 октября &mdash; 20 октября"
                },
                {
                  "start": "20241021",
                  "end": "20241027",
                  "title": "21 октября &mdash; 27 октября"
                },
                {
                  "start": "20241028",
                  "end": "20241103",
                  "title": "28 октября &mdash; 03 ноября"
                }
              ]
            },
            {
              "name": "II",
              "fullname": "II четверть",
              "disabled": false,
              "ambigious": null,
              "start": "20241111",
              "end": "20241230",
              "weeks": [
                {
                  "start": "20241111",
                  "end": "20241117",
                  "title": "11 ноября &mdash; 17 ноября"
                },
                {
                  "start": "20241118",
                  "end": "20241124",
                  "title": "18 ноября &mdash; 24 ноября"
                },
                {
                  "start": "20241125",
                  "end": "20241201",
                  "title": "25 ноября &mdash; 01 декабря"
                },
                {
                  "start": "20241202",
                  "end": "20241208",
                  "title": "02 декабря &mdash; 08 декабря"
                },
                {
                  "start": "20241209",
                  "end": "20241215",
                  "title": "09 декабря &mdash; 15 декабря"
                },
                {
                  "start": "20241216",
                  "end": "20241222",
                  "title": "16 декабря &mdash; 22 декабря"
                },
                {
                  "start": "20241223",
                  "end": "20241229",
                  "title": "23 декабря &mdash; 29 декабря"
                },
                {
                  "start": "20241230",
                  "end": "20250105",
                  "title": "30 декабря &mdash; 05 января"
                }
              ]
            },
            {
              "name": "III",
              "fullname": "III четверть",
              "disabled": false,
              "ambigious": null,
              "start": "20250120",
              "end": "20250322",
              "weeks": [
                {
                  "start": "20250120",
                  "end": "20250126",
                  "title": "20 января &mdash; 26 января"
                },
                {
                  "start": "20250127",
                  "end": "20250202",
                  "title": "27 января &mdash; 02 февраля"
                },
                {
                  "start": "20250203",
                  "end": "20250209",
                  "title": "03 февраля &mdash; 09 февраля"
                },
                {
                  "start": "20250210",
                  "end": "20250216",
                  "title": "10 февраля &mdash; 16 февраля"
                },
                {
                  "start": "20250217",
                  "end": "20250223",
                  "title": "17 февраля &mdash; 23 февраля"
                },
                {
                  "start": "20250224",
                  "end": "20250302",
                  "title": "24 февраля &mdash; 02 марта"
                },
                {
                  "start": "20250303",
                  "end": "20250309",
                  "title": "03 марта &mdash; 09 марта"
                },
                {
                  "start": "20250310",
                  "end": "20250316",
                  "title": "10 марта &mdash; 16 марта"
                },
                {
                  "start": "20250317",
                  "end": "20250323",
                  "title": "17 марта &mdash; 23 марта"
                }
              ]
            },
            {
              "name": "IV",
              "fullname": "IV четверть",
              "disabled": false,
              "ambigious": null,
              "start": "20250331",
              "end": "20250524",
              "weeks": [
                {
                  "start": "20250331",
                  "end": "20250406",
                  "title": "31 марта &mdash; 06 апреля"
                },
                {
                  "start": "20250407",
                  "end": "20250413",
                  "title": "07 апреля &mdash; 13 апреля"
                },
                {
                  "start": "20250414",
                  "end": "20250420",
                  "title": "14 апреля &mdash; 20 апреля"
                },
                {
                  "start": "20250421",
                  "end": "20250427",
                  "title": "21 апреля &mdash; 27 апреля"
                },
                {
                  "start": "20250428",
                  "end": "20250504",
                  "title": "28 апреля &mdash; 04 мая"
                },
                {
                  "start": "20250505",
                  "end": "20250511",
                  "title": "05 мая &mdash; 11 мая"
                },
                {
                  "start": "20250512",
                  "end": "20250518",
                  "title": "12 мая &mdash; 18 мая"
                },
                {
                  "start": "20250519",
                  "end": "20250525",
                  "title": "19 мая &mdash; 25 мая"
                }
              ]
            }
          ]
        }
      ]
    }
  }
}
и сам запрос
class EljurMobileAPI:
    """
    Полный API-клиент для мобильного приложения Эльжур.
    Реализует все запросы, обнаруженные в перехваченном трафике.
    """
    
    # Основной URL API
    BASE_URL = "https://eljur.gospmr.org/apiv3/"
    
    # Ключ разработчика
    DEV_KEY = "dd06cf484d85581e1976d93c639deee7"
    
    def __init__(self):
        """Инициализация клиента API."""
        self.auth_token = None
        self.student_id = None
        self.student_class = None
        self.domain = None
        self.cookies = {}
        self.session = requests.Session()
    def get_periods(self, weeks: bool = True, show_disabled: bool = True) -> Dict[str, Any]:
        """
        Получить периоды обучения.
        
        Args:
            weeks: Включать информацию о неделях
            show_disabled: Показывать отключенные периоды
            
        Returns:
            Dict с периодами обучения
        """
        print("\nПолучение периодов обучения...")
        
        # Проверяем, авторизован ли пользователь
        if not self.auth_token:
            print("Необходимо сначала авторизоваться.")
            return {"error": "Not authenticated"}
        
        # Параметры запроса
        params = {
            "weeks": "true" if weeks else "false",
            "show_disabled": "true" if show_disabled else "false",
            "devkey": self.DEV_KEY,
            "out_format": "json",
            "auth_token": self.auth_token,
            "vendor": "eljur"
        }
        
        # Заголовки запроса
        headers = {
            "user-agent": "",
            "accept-encoding": "gzip"
        }
        
        # URL для получения периодов обучения
        url = f"{self.BASE_URL}getperiods"
        
        # Выполняем запрос
        response = self.session.get(
            url, 
            params=params, 
            headers=headers, 
            cookies=self.cookies
        )
        
        print(f"URL запроса: {response.url}")
        print(f"Статус ответа: {response.status_code}")
        
        # Обрабатываем ответ
        result = self._process_response(response, "periods")
        return result
запрос на дневник 
    def get_diary(self, days: Optional[str] = None) -> Dict[str, Any]:
        """
        Получить дневник.
        
        Args:
            days: Период дней для дневника в формате 'YYYYMMDD-YYYYMMDD'
        
        Returns:
            Dict с дневником
        """
        print("\nПолучение дневника...")
        
        # Проверяем, авторизован ли пользователь
        if not self.auth_token or not self.student_id:
            print("Необходимо сначала авторизоваться и получить информацию о пользователе.")
            return {"error": "Not authenticated or incomplete user info"}
        
        # Если не указан период дней, используем текущую неделю
        if not days:
            # В реальном приложении тут должна быть логика вычисления текущей недели
            days = "20250512-20250518"  # Текущая неделя из перехваченного трафика
        
        # Параметры запроса
        params = {
            "student": self.student_id,
            "days": days,
            "rings": "true",
            "devkey": self.DEV_KEY,
            "out_format": "json",
            "auth_token": self.auth_token,
            "vendor": "eljur"
        }
        
        # Заголовки запроса
        headers = {
            "user-agent": "",
            "accept-encoding": "gzip"
        }
        
        # URL для получения дневника
        url = f"{self.BASE_URL}getdiary"
        
        # Выполняем запрос
        response = self.session.get(
            url, 
            params=params, 
            headers=headers, 
            cookies=self.cookies
        )
        
        print(f"URL запроса: {response.url}")
        print(f"Статус ответа: {response.status_code}")
        
        # Обрабатываем ответ
        result = self._process_response(response, f"diary_{days}")
        return result
   
запрос на сообщения(полученые/отправленные/отправить сообщение/получатели)
    def get_messages(self, folder="inbox", unread_only=False, limit=200, page=1, filter_str=""):
        """
        Получение списка сообщений из указанной папки.
        
        Args:
            folder: Папка с сообщениями ('inbox' - входящие, 'sent' - отправленные)
            unread_only: Показывать только непрочитанные сообщения
            limit: Ограничение количества сообщений (0 - без ограничения)
            page: Номер страницы
            filter_str: Строка фильтрации
            
        Returns:
            Dict с данными ответа или информацией об ошибке
        """
        if not self.is_authenticated():
            return {"error": "Пользователь не авторизован"}
        
        if not self.student_id:
            return {"error": "ID студента не найден"}
        
        # Параметры запроса
        unread_param = "yes" if unread_only else "no"
        params = {
            "folder": folder,
            "unreadonly": unread_param,
            "limit": limit,
            "page": page,
            "filter": filter_str
        }
        
        # Добавляем служебные параметры
        params.update(self._get_common_params())
        
        # Формируем URL запроса
        url = f"{self.BASE_URL}getmessages"
        
        print(f"Получение сообщений из папки {folder}...")
        print(f"URL запроса: {url}?{urlencode(params)}")
        
        # Выполняем запрос
        response = requests.get(
            url,
            params=params,
            headers=self._get_headers()
        )
        
        print(f"Статус ответа: {response.status_code}")
        
        # Обрабатываем ответ
        result = self._process_response(response, f"messages_{folder}_page{page}")
        
        # Возвращаем результат
        return result
    
    def get_message_details(self, message_id):
        """
        Получение деталей конкретного сообщения.
        
        Args:
            message_id: Идентификатор сообщения
            
        Returns:
            Dict с данными ответа или информацией об ошибке
        """
        if not self.is_authenticated():
            return {"error": "Пользователь не авторизован"}
        
        if not self.student_id:
            return {"error": "ID студента не найден"}
        
        # Параметры запроса
        params = {
            "id": message_id
        }
        
        # Добавляем служебные параметры
        params.update(self._get_common_params())
        
        # Формируем URL запроса - используем правильный эндпоинт
        url = f"{self.BASE_URL}getmessageinfo"
        
        print(f"Получение деталей сообщения с ID {message_id}...")
        print(f"URL запроса: {url}?{urlencode(params)}")
        
        # Выполняем запрос
        response = requests.get(
            url,
            params=params,
            headers=self._get_headers()
        )
        
        print(f"Статус ответа: {response.status_code}")
        
        # Обрабатываем ответ
        result = self._process_response(response, f"message_details_{message_id}")
        
        # Возвращаем результат
        return result
    def get_message_receivers(self):
        """
        Получение списка доступных получателей сообщений.
        
        Returns:
            Dict с данными о доступных получателях сообщений
        """
        if not self.is_authenticated():
            return {"error": "Пользователь не авторизован"}
        
        if not self.student_id:
            return {"error": "ID студента не найден"}
        
        # Формируем URL запроса
        url = f"{self.BASE_URL}getmessagereceivers"
        
        # Добавляем служебные параметры
        params = self._get_common_params()
        
        print(f"Получение списка доступных получателей сообщений...")
        print(f"URL запроса: {url}?{urlencode(params)}")
        
        # Выполняем запрос
        response = requests.get(
            url,
            params=params,
            headers=self._get_headers()
        )
        
        print(f"Статус ответа: {response.status_code}")
        
        # Обрабатываем ответ
        result = self._process_response(response, "message_receivers")
        
        # Возвращаем результат
        return result
    
    def send_message(self, recipients, subject, text, attachments=None):
        """
        Отправка сообщения.
        
        Args:
            recipients: Список идентификаторов получателей
            subject: Тема сообщения
            text: Текст сообщения
            attachments: Список вложений (опционально)
            
        Returns:
            Dict с данными ответа или информацией об ошибке
        """
        if not self.is_authenticated():
            return {"error": "Пользователь не авторизован"}
        
        if not self.student_id:
            return {"error": "ID студента не найден"}
        
        # Формируем URL запроса
        url = f"{self.BASE_URL}sendmessage"
        
        # Служебные параметры в URL
        url_params = self._get_common_params()
        url_with_params = f"{url}?{urlencode(url_params)}"
        
        # Данные формы для отправки
        form_data = {
            "users_to": ",".join(recipients) if isinstance(recipients, list) else recipients,
            "subject": subject,
            "text": text
        }
        
        # Добавляем вложения, если они есть
        if attachments:
            for i, attachment in enumerate(attachments):
                form_data[f"attach{i+1}"] = attachment
        
        print(f"Отправка сообщения...")
        print(f"URL запроса: {url_with_params}")
        print(f"Получатели: {form_data['users_to']}")
        
        # Выполняем запрос
        response = requests.post(
            url_with_params,
            data=form_data,
            headers=self._get_headers()
        )
        
        print(f"Статус ответа: {response.status_code}")
        
        # Обрабатываем ответ
        result = self._process_response(response, "message_send")
        
        # Возвращаем результат
        return result
    
запрос на получение оценок
    def get_marks(self, period=None, start_date=None, end_date=None):
        """
        Получение оценок за выбранный период.
        
        Args:
            period: Номер четверти (1-4) или None для произвольного периода
            start_date: Начальная дата в формате "YYYYMMDD" для произвольного периода
            end_date: Конечная дата в формате "YYYYMMDD" для произвольного периода
            
        Returns:
            Dict с оценками за выбранный период
        """
        if not self.is_authenticated():
            return {"error": "Пользователь не авторизован"}
        
        if not self.student_id:
            return {"error": "ID студента не найден"}
            
        # Определяем даты периода на основе выбранной четверти
        if period is not None:
            # Даты четвертей из перехваченного трафика
            quarters = {
                1: ("20240903", "20241102"),  # Первая четверть
                2: ("20241111", "20241230"),  # Вторая четверть
                3: ("20250120", "20250322"),  # Третья четверть
                4: ("20250331", "20250524")   # Четвертая четверть
            }
            
            if period not in quarters:
                return {"error": f"Неверный номер четверти: {period}. Доступны номера 1-4."}
                
            start_date, end_date = quarters[period]
        elif start_date is None or end_date is None:
            # Если не указаны ни четверть, ни даты - используем текущую (четвертую) четверть
            start_date, end_date = "20250331", "20250524"
            
        # Параметры запроса
        params = {
            "student": self.student_id,
            "days": f"{start_date}-{end_date}"
        }
        
        # Добавляем служебные параметры
        params.update(self._get_common_params())
        
        # Формируем URL запроса
        url = f"{self.BASE_URL}getmarks"
        
        print(f"Получение оценок за период {start_date}-{end_date}...")
        print(f"URL запроса: {url}?{urlencode(params)}")
        
        # Выполняем запрос
        response = requests.get(
            url,
            params=params,
            headers=self._get_headers()
        )
        
        print(f"Статус ответа: {response.status_code}")
        
        # Обрабатываем ответ
        result = self._process_response(response, f"marks_{start_date}-{end_date}")
        
        # Возвращаем результат
        return result